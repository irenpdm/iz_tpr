'use strict';

// Вводная матрица: вводится вручную

let matrix = [
    [6, 4, 6, 5, 7, 4],
    [5, 2, 3, 6, 6, 7]
];

//--------------------------------------------

// Проверка на верность формата матрицы

if (matrix.length == 3) { //если в матрице три строки то идем дальше

    // Нахождение min элементов в 1 и 3 строках и max во 2

    let min1 = Math.min.apply(null,matrix[0]);
    let min3 = Math.min.apply(null, matrix[2]);
    let max2 = Math.max.apply(null, matrix[1]);

    //.......................................................

    // Проверка можно ли свести к двум машинам

    if (min1 >= max2) { //если мин элемент 1 строки больше либо равен макс элементу 2 то идем дальше
        let sum = [];
        for (let i = 0; i < matrix[0].length; i++) { //для каждого элемента строки
            sum.push(matrix[0][i] + matrix[1][i]);   //складываем элемент 1 и 2 строки
        }
        matrix = [sum, matrix[2]]; //создаем матрицу из полученной суммы и 3 строки
    } else if (min3 >= max2) { //если мин элемент 3 строки больше либо равен макс элементу 2 то идем дальше
        let sum = [];
        for (let i = 0; i < matrix[0].length; i++) { //для каждого элемента строки
            sum.push(matrix[2][i] + matrix[1][i]);   //складываем элемент 3 и 2 строки
        }
        matrix = [matrix[0], sum]; //создаем матрицу из полученной суммы и 1 строки
    } else {
        console.log('Невозможно свести задачу к двум машинам! Попробуйте ввести другие данные.');

        //прерывание программы

        process.stdin.setRawMode(true);
        process.stdin.resume();
        process.stdin.on('data', process.exit.bind(process, 0));
        return false;

        //=======================

    }

    //.......................................................

} else if (matrix.length !== 2) { //если в матрице не две строки то идем дальше
    console.log('Матрица должна содержать не менее двух и не более трех строк!');

    //прерывание программы

    process.stdin.setRawMode(true);
    process.stdin.resume();
    process.stdin.on('data', process.exit.bind(process, 0));
    return false;

    //==============================

}

//--------------------------------------------

//Создаем пустую матрицу элементов идентичную длине вводной матрицы

let optim = [[], [], []]; //матрица результат вычислений
let num = []; //массив номеров столбцов

for (let i = 0; i < matrix[0].length; i++) { //для каждого элемента строки
    num.push(i + 1);  //добавляем номер столбца
    optim[0].push(0); //заполняем матрицу нулями
    optim[1].push(0);
    optim[2].push(0);
}

//--------------------------------------------

let length = matrix[0].length; //исходная длина строки

//Решение алгоритмом Джонсона

for (let i = 0, k = 0, j = 0, index = []; 0 < matrix[0].length; i++) { //для каждого элемента строки

    let el = []; //массив элементов из противоположной строки
    let index = []; //массив индексов
    
    if (Math.min.apply(null, matrix[0]) <= Math.min.apply(null, matrix[1])) { //если min элемент находится в первой строке

        //Отбираем все элементы с минимальным значением в первой строке

        matrix[0].filter((el, ind) => {
            if (el == Math.min.apply(null, matrix[0])) index.push(ind);
            return el;
        });

        //.......................................................

        //Создаем массив соответсвующих элементов во второй строке

        for (let a = 0; a < index.length; a++) {
            el.push(matrix[1][index[a]]);
        }

        //.......................................................

        //Переносим элементы на соответсвующее место в новой матрице

        for (let a = 0, ind = 0; a < index.length; a++) {
            ind = el.indexOf(Math.max.apply(null, el)); //находим индекс максимального эл из второй строки

            //Заносим элемент 1 и 2 строки и их номер

            optim[0].splice(k, 1, num[index[ind]]);
            optim[1].splice(k, 1, matrix[0][index[ind]]);
            optim[2].splice(k, 1, matrix[1][index[ind]]);

            //========================================

            el.splice(ind, 1); //исключаем внесенный элемент из массива
            k++; //считаем сколько элементов было занесено слева

            console.log("<Номер: " + num[index[ind]] + "Место: " + optim[0].indexOf(num[index[ind]]));

            //Исключаем элемент 1 и 2 строки и их номер из вводной матрицы

            matrix[0].splice(index[ind], 1);
            matrix[1].splice(index[ind], 1);
            num.splice(index[ind], 1);

            //========================================
        }

        //.......................................................

    } else { //если min элемент находится не в первой строке

        //Отбираем все элементы с минимальным значением во второй строке

        matrix[1].filter((el, ind) => {
            if (el == Math.min.apply(null, matrix[1])) index.push(ind);
            return el;
        });

        //.......................................................

        //Создаем массив соответсвующих элементов в первой строке

        for (let a = 0; a < index.length; a++) {
            el.push(matrix[0][index[a]]);
        }

        //.......................................................

        //Переносим элементы на соответсвующее место в новой матрице

        for (let a = 0, ind = 0; a < index.length; a++) {
            ind = el.indexOf(Math.max.apply(null, el)); //находим индекс максимального эл из первой строки

            //Заносим элемент 1 и 2 строки и их номер

            optim[0].splice(length - j - 1, 1, num[index[ind]]);
            optim[1].splice(length - j - 1, 1, matrix[0][index[ind]]);
            optim[2].splice(length - j - 1, 1, matrix[1][index[ind]]);

            //========================================

            el.splice(ind, 1); //исключаем внесенный элемент из массива
            j++; //считаем сколько элементов было занесено справа

            console.log(">Номер: " + num[index[ind]] + "Место: " + optim[0].indexOf(num[index[ind]]));

            //Исключаем элемент 1 и 2 строки и их номер из вводной матрицы

            matrix[0].splice(index[ind], 1);
            matrix[1].splice(index[ind], 1);
            num.splice(index[ind], 1);

            //========================================
        } 

        //.......................................................
    }
    
}

//--------------------------------------------

console.log("Оптимальный порядок: " + optim[0].join(' - ') + ".");

//Считаем общее время и простой

for (var i = 0, sum1 = 0, sum2 = optim[1][0], prost = optim[1][0]; i < optim[0].length; i++) { //для каждого элемента строки

    sum1 = sum1 + optim[1][i]; //прибавляем элемент первой строки

    while (sum1 > sum2) { //если сумма первой строки больше суммы второй
        sum2 = sum2 + 1;  //прибавляем ко второй сумме 1
        prost++;          //и 1 к простою
    }

    sum2 = sum2 + optim[2][i]; //прибавляем элемент второй строки
}

//--------------------------------------------

console.log("Общее время: " + sum2 + "Простой: " + prost);